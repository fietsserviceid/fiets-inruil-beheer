name: Beheer (refill + assign) ‚Äî codes.json in calculator (PR-flow)

on:
  issues:
    types: [opened, edited, labeled, reopened]
  workflow_dispatch:

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  process:
    # Handmatige runs altijd; bij issues alleen als 'beheer' op de issue staat
    if: ${{ github.event_name == 'workflow_dispatch' || (github.event_name == 'issues' && contains(join(github.event.issue.labels.*.name, ','), 'beheer')) }}
    runs-on: ubuntu-latest

    steps:
      # Failsafe: zet 'beheer' als titel met [Codes] begint (alleen bij issues-event)
      - name: Auto-label beheer bij [Codes] in titel
        if: ${{ github.event_name == 'issues' && startsWith(github.event.issue.title, '[Codes]') }}
        uses: actions-ecosystem/action-add-labels@v1
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          labels: "beheer"

      # Checkout beheer (voor dealers.json e.d.)
      - name: Checkout beheer-repo
        uses: actions/checkout@v4

      # Checkout calculator (target) naar ./target
      - name: Checkout calculator-repo (target)
        uses: actions/checkout@v4
        with:
          repository: fietsserviceid/fiets-inruil-calculator
          token: ${{ secrets.TARGET_REPO_PAT }}   # PAT met Contents: Read & Write op target-repo
          path: target
          ref: main

      # Verifieer dat target/codes.json bestaat
      - name: Verify target/codes.json
        shell: bash
        run: |
          if [ ! -f "target/codes.json" ]; then
            echo "ERROR: target/codes.json bestaat niet. Voeg het bestand toe in fiets-inruil-calculator (root) en probeer opnieuw."
            exit 1
          fi

      # Parse Issue Form ‚Äî zentered v2.0.0 publiceert outputs.data en heeft geen inputs nodig
      - name: Parse Issue Form
        if: ${{ github.event_name == 'issues' }}
        id: form
        uses: zentered/issue-forms-body-parser@v2.0.0

      # Refill/Assign (schema-agnostisch)
      - name: Run manage (refill/assign)
        id: manage
        shell: bash
        env:
          # Bij issues: labels van het issue; bij dispatch: leeg (mag)
          LABELS: ${{ github.event_name == 'issues' && join(github.event.issue.labels.*.name, ',') || '' }}
          # Bij issues: geparste form-data; bij dispatch: leeg (mag)
          FORM:   ${{ steps.form.outputs.data }}
        run: |
          set -euo pipefail

          # Werkbestand vanuit target
          cp target/codes.json ./codes.json

          # Dealerslijst (uit beheer-repo). Alleen init als hij niet bestaat.
          if [ ! -f "dealers.json" ]; then
            echo "[]" > dealers.json
          fi

          # ---------- manage.js: schema-agnostisch ----------
          cat > manage.js <<'NODE'
          const fs = require('fs');

          const now = new Date().toISOString();
          const codesPath   = 'codes.json';
          const dealersPath = 'dealers.json';

          const readJson = (p, fb=null) => { try { return JSON.parse(fs.readFileSync(p,'utf8')); } catch { return fb; } };
          const writeJson = (p, obj) => fs.writeFileSync(p, JSON.stringify(obj, null, 2));

          // Labels case-insensitive
          const labels = (process.env.LABELS || '')
            .split(',')
            .map(s => s.trim().toLowerCase())
            .filter(Boolean);

          // Form-payload (kan leeg zijn bij workflow_dispatch)
          const payload = JSON.parse(process.env.FORM || '{}');

          // Haal velden op op basis van de TITEL in je Issue Form
          const byTitle = (t) => {
            const vals = Object.values(payload || {});
            const f = vals.find(v => v && typeof v.title==='string' && v.title.trim().toLowerCase()===t.trim().toLowerCase());
            if (!f) return '';
            if (typeof f.text==='string') return f.text;
            if (typeof f==='string') return f;
            return '';
          };

          // Helpers
          const CODE_REGEX = /^FSID-[A-Z]{4}-\d{4}-\d{4}$/;     // codeformat afdwingen
          const isDMY = (s) => /^\d{2}-\d{2}-\d{4}$/.test(s);   // dd-mm-jjjj
          const pick = (s) => s[Math.floor(Math.random()*s.length)];
          const genFromFormat = (fmt='FSID-AAAA-9999-9999') => {
            const A='ABCDEFGHJKLMNPQRSTUVWXYZ'; const N='0123456789';
            return [...fmt].map(ch => ch==='A'?pick(A):ch==='9'?pick(N):ch).join('');
          };

          const raw = readJson(codesPath, null);
          if (!raw) throw new Error('codes.json kon niet gelezen worden of is leeg.');

          // ---- schema-detectie ----
          // Modes:
          //  - flatArr:  root is array
          //  - propArr:  root is object met array onder √©√©n van: distinct, codes, available, pool, data, items
          //  - mapObj:   root is object mapping { "FSID-....": {...} }
          let mode = null;
          let container = null;    // verwijzing naar root object (bij propArr/mapObj)
          let prop = null;         // naam van de array-property (bij propArr)
          let list = null;         // array-reference die we bewerken
          let listWasStrings = false; // als entries strings zijn i.p.v. objects

          if (Array.isArray(raw)) {
            mode = 'flatArr';
            list = raw;
          } else if (raw && typeof raw === 'object') {
            // 1) bekende array-keys
            const candidates = ['distinct','codes','available','pool','data','items'];
            const hit = candidates.find(k => Array.isArray(raw[k]));
            if (hit) {
              mode = 'propArr';
              container = raw;
              prop = hit;
              list = raw[hit];
            } else {
              // 2) mapping van code -> object?
              const keys = Object.keys(raw);
              const looksLikeCode = k => /^FSID-[A-Z0-9]{4}-\d{4}-\d{4}$/.test(String(k));
              const codeKeys = keys.filter(looksLikeCode);
              const valuesAreObjects = codeKeys.length>0 && codeKeys.every(k => raw[k] && typeof raw[k] === 'object');
              if (valuesAreObjects) {
                mode = 'mapObj';
                container = raw;
                // zet tijdelijke list als array van { code, ...props }
                list = codeKeys.map(k => ({ code: k, ...(raw[k]||{}) }));
              }
            }
          }
          if (!mode) throw new Error('Niet-ondersteund schema in target/codes.json (geen array of object met herkenbare structuur).');

          // normalizeer list-elementen naar objecten met .code
          if (Array.isArray(list) && list.length && typeof list[0] !== 'object') {
            // array van strings -> merken en converteren voor mutatie
            listWasStrings = true;
            list = list.map(v => (typeof v === 'string') ? { code: v } : v );
          }

          const existingCodes = new Set(list.map(e => e && e.code).filter(Boolean));

          // id-generator fsc-0001
          let max = 0;
          for (const e of list) {
            const m = (e && e.id ? String(e.id) : '').match(/^fsc-(\d{4})$/i);
            if (m) max = Math.max(max, parseInt(m[1],10));
          }
          const nextId = (n)=> `fsc-${String(max+n).padStart(4,'0')}`;

          let msg = 'geen wijziging';
          let changed = false;

          // ---------- REFILL ----------
          if (labels.includes('codes:refill')) {
            const count  = Math.max(1, parseInt((byTitle('Aantal te genereren')||'').trim() || '200', 10));
            const dmyRaw = (byTitle('Vervaldatum (dd-mm-jjjj, optioneel)')||'').trim();
            const vervaltOp = dmyRaw ? (isDMY(dmyRaw) ? dmyRaw : null) : null;

            const pasted = (byTitle('Eigen codes (optioneel, √©√©n per regel)')||'')
              .split(/\r?\n/).map(s=>s.trim()).filter(Boolean);

            const source = pasted.length ? pasted : Array.from({length: count}, ()=> genFromFormat());

            // Validatie format
            const bad = source.filter(c => !CODE_REGEX.test(c));
            if (bad.length) throw new Error(`Fout code-format: ${bad.join(', ')}`);

            // Uniciteit t.o.v. bestaande
            const dups = source.filter(c => existingCodes.has(c));
            if (dups.length) throw new Error(`Dubbele codes t.o.v. bestaande set: ${dups.join(', ')}`);

            // Append
            source.forEach((code, i) => {
              const id = nextId(i+1);
              const entry = { id, code, status: 'actief', dealerId: null, dealerNaam: null,
                              vervaltOp, aangemaaktOp: now, gebruiktOp: null, notities: '' };
              list.push(entry);
              existingCodes.add(code);
              changed = true;
            });

            msg = `chore(codes): refill +${source.length} (zonder dealer)`;
          }

          // ---------- ASSIGN ----------
          if (labels.includes('codes:assign')) {
            const dealerId = (byTitle('Dealer ID')||'').trim();
            if (!dealerId) throw new Error('Dealer ID ontbreekt.');

            const dealersArr = readJson(dealersPath, []);
            const dealer = dealersArr.find(d => d.dealerId === dealerId);
            if (!dealer) throw new Error(`Dealer niet gevonden in beheer/dealers.json: ${dealerId}`);

            const want  = Math.max(1, parseInt((byTitle('Aantal codes toe te wijzen')||'').trim() || '1', 10));
            const fixed = (byTitle('Specifieke bestaande codes (optioneel, √©√©n per regel)')||'')
              .split(/\r?\n/).map(s=>s.trim()).filter(Boolean);

            if (listWasStrings) {
              throw new Error('Je probeert codes toe te wijzen terwijl codes.json alleen strings bevat. Toewijzingsmetadata past niet in string-schema.');
            }

            let toAssign = [];

            if (fixed.length) {
              const bad = fixed.filter(c => !CODE_REGEX.test(c));
              if (bad.length) throw new Error(`Fout code-format: ${bad.join(', ')}`);
              for (const val of fixed) {
                const entry = list.find(e => e && e.code === val);
                if (!entry) throw new Error(`Code niet gevonden in target/codes.json: ${val}`);
                if (entry.dealerId) throw new Error(`Code al toegewezen: ${val}`);
                toAssign.push(entry);
              }
            } else {
              toAssign = list.filter(e => e && !e.dealerId).slice(0, want);
              if (toAssign.length < want) throw new Error(`Onvoldoende vrije codes. Gevraagd: ${want}, beschikbaar: ${toAssign.length}`);
            }

            toAssign.forEach(e => {
              e.dealerId   = dealer.dealerId;
              e.dealerNaam = dealer.naam || dealer.dealerNaam || dealer.dealer_id || dealer.dealerId;
              e.status     = 'toegewezen';
              e.notities   = (e.notities || '') + (e.notities ? ' ¬∑ ' : '') + 'toegewezen via beheer';
            });

            msg = `chore(codes): assigned ${toAssign.length} to ${dealerId}`;
            changed = true;
          }

          // ---- terugschrijven in hetzelfde schema ----
          let out;
          if (mode === 'flatArr') {
            out = listWasStrings ? list.map(e => e.code) : list;
            writeJson(codesPath, out);
          } else if (mode === 'propArr') {
            container[prop] = listWasStrings ? list.map(e => e.code) : list;
            // set meta.lastUpdated als meta bestaat
            if (container.meta && typeof container.meta === 'object') {
              container.meta.lastUpdated = new Date().toISOString();
            }
            writeJson(codesPath, container);
          } else if (mode === 'mapObj') {
            // bouw mapping terug (code -> props)
            const map = {};
            for (const e of list) {
              const { code, ...rest } = e || {};
              if (!code) continue;
              map[code] = rest;
            }
            writeJson(codesPath, map);
          } else {
            throw new Error('Interne fout: onbekende mode tijdens save().');
          }

          // Outputs
          fs.writeFileSync('commit_msg.txt', msg);
          fs.writeFileSync('changed.out', String(!!changed));
          console.log(msg);
          NODE

          node manage.js

          # Mutatie terugschrijven naar target/
          mv ./codes.json target/codes.json

          echo "MSG=$(cat commit_msg.txt)" >> $GITHUB_OUTPUT
          echo "CHANGED=$(cat changed.out)" >> $GITHUB_OUTPUT

      # Debug: tel codes generiek (array of diverse objecten)
      - name: Debug aantal codes
        run: |
          echo "Aantal entries in target/codes.json:"
          jq 'if type=="array" then length
              elif has("distinct") and (.distinct|type=="array") then .distinct|length
              elif has("codes") and (.codes|type=="array") then .codes|length
              elif has("available") and (.available|type=="array") then .available|length
              elif has("pool") and (.pool|type=="array") then .pool|length
              elif has("data") and (.data|type=="array") then .data|length
              elif has("items") and (.items|type=="array") then .items|length
              else (keys|length)
              end' target/codes.json || true

      # PR aanmaken in calculator ‚Äî alleen als er wijzigingen zijn
      - name: Create PR in calculator
        if: ${{ steps.manage.outputs.CHANGED == 'true' }}
        id: cpr
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.TARGET_REPO_PAT }}
          path: target
          commit-message: ${{ steps.manage.outputs.MSG }}
          title: ${{ steps.manage.outputs.MSG }}
          body: |
            Automatische update vanuit beheer-issue #${{ github.event.issue.number }}.
            (PR-flow; geen directe push)
          branch: chore/managed-codes-${{ github.event.issue.number }}
          labels: admin,internal

      # Altijd commenten; JS beslist welke tekst
      - name: Comment with PR link
        uses: actions/github-script@v7
        env:
          PR_URL: ${{ steps.cpr.outputs['pull-request-url'] }}
          MSG:    ${{ steps.manage.outputs.MSG }}
          CHG:    ${{ steps.manage.outputs.CHANGED }}
        with:
          script: |
            const url = process.env.PR_URL || '';
            const changed = (process.env.CHG || '').toLowerCase() === 'true';
            let body;
            if (!changed) {
              body = `‚ÑπÔ∏è Geen wijzigingen gedetecteerd ‚Äî er is geen PR aangemaakt.\n\nZorg dat het issue labels bevat als **codes:refill** of **codes:assign** (en **beheer**).`;
            } else {
              body = url
                ? `üîÅ PR aangemaakt in calculator: ${url}`
                : '‚ÑπÔ∏è Wijzigingen verwerkt, maar er is geen PR-URL ontvangen.';
            }
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body
            });
